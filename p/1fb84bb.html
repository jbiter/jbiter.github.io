<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico"><link rel="icon" href="/img/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="布衣"><meta name="keywords" content="黑暗森林"><meta name="description" content="[TOC] 1 PageRank算法1.1 算法来源网页文本检索系统根据用户查询关键词与网页内容的相关程度来返回搜索结果，但是搜索结果未能体现页面的重要性。某些网页也可以通过堆砌关键词使自己的搜索排名靠前。于是，谷歌的两位创始人，当时还是美国斯坦福大学（Stanford University）研究生的佩奇（Larry Page）和布林（Sergey Brin）开始了对网页排序问题的研究。他们借鉴了"><meta property="og:type" content="article"><meta property="og:title" content="从PageRank到CoRank"><meta property="og:url" content="https://jbiter.github.io/p/1fb84bb.html"><meta property="og:site_name" content="黑暗森林 — 没有人妨碍我的自由，是我的生活本身汲干了我的自由。"><meta property="og:description" content="[TOC] 1 PageRank算法1.1 算法来源网页文本检索系统根据用户查询关键词与网页内容的相关程度来返回搜索结果，但是搜索结果未能体现页面的重要性。某些网页也可以通过堆砌关键词使自己的搜索排名靠前。于是，谷歌的两位创始人，当时还是美国斯坦福大学（Stanford University）研究生的佩奇（Larry Page）和布林（Sergey Brin）开始了对网页排序问题的研究。他们借鉴了"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jbiter.github.io/img/post/study/page-rank-mind.png"><meta property="article:published_time" content="2021-07-06T02:10:46.000Z"><meta property="article:modified_time" content="2022-11-05T11:46:27.346Z"><meta property="article:author" content="布衣"><meta property="article:tag" content="Private"><meta property="article:tag" content="PageRank"><meta property="article:tag" content="LeaderRank"><meta property="article:tag" content="CoRank"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://jbiter.github.io/img/post/study/page-rank-mind.png"><title>从PageRank到CoRank — 黑暗森林 — 没有人妨碍我的自由，是我的生活本身汲干了我的自由。</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"jbiter.github.io",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!1,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"b8JD74lbn6aNJFquYBszLovF-gzGzoHsz",app_key:"VqnFRQzrPS8iVFRTUXLBPOsK",server_url:"https://b8jd74lb.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>黑暗森林</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/">首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/">归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/">类别</a></li><li class="nav-item"><a class="nav-link" href="/tags/">标签</a></li><li class="nav-item"><a class="nav-link" href="/links/">友链</a></li><li class="nav-item"><a class="nav-link" href="/about/">关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" rel="external nofollow noreferrer" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" rel="external nofollow noreferrer" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/theme/hd/09.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="从PageRank到CoRank"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 布衣 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-07-06 10:10" pubdate>2021年7月6日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>共 9.4k 词 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>约78分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">从PageRank到CoRank</h1><div class="markdown-body"><p>[TOC]</p><h2 id="1-PageRank算法"><a href="#1-PageRank算法" class="headerlink" title="1 PageRank算法"></a>1 PageRank算法</h2><h3 id="1-1-算法来源"><a href="#1-1-算法来源" class="headerlink" title="1.1 算法来源"></a>1.1 算法来源</h3><p>网页文本检索系统根据用户查询关键词与网页内容的相关程度来返回搜索结果，但是搜索结果未能体现页面的重要性。某些网页也可以通过堆砌关键词使自己的搜索排名靠前。于是，谷歌的两位创始人，当时还是美国斯坦福大学（Stanford University）研究生的佩奇（Larry Page）和布林（Sergey Brin）开始了对网页排序问题的研究。他们借鉴了学术界评判学术论文重要性的通用方法——论文的引用次数，于1998年提出了PageRank网页排序算法<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[BRIN S, PAGE L. The anatomy of a large-scale hypertextual Web search engine[J]. Computer Networks and ISDN Systems, 1998, 30(1–7): 107–117. DOI:10.1016/s0169-7552(98)00110-x.](https://www.sciencedirect.com/science/article/abs/pii/S016975529800110X?via%3Dihub)">[1]</span></a></sup>。PageRank算法的核心思想非常简单：</p><ul><li><p><strong>如果一个网页被很多其他网页链接到的话，说明这个网页比较重要，其PageRank值会相对较高</strong></p></li><li><p><strong>如果一个PageRank值很高的网页链接到一个其他的网页，那么被链接到的网页的PageRank值会相应地提高</strong></p></li></ul><p>如下图所示:</p><p><img src="../../img/post/study/page-rank-mind.png" srcset="/img/loading.gif" lazyload alt="图1-1: PageRank算法概念图" style="zoom:67%"></p><h3 id="1-2-算法原理"><a href="#1-2-算法原理" class="headerlink" title="1.2 算法原理"></a>1.2 算法原理</h3><p>互联网中的众多网页可以看作一个有向图。下图是一个简单的例子：</p><p><img src="../../img/post/study/pr-1.jpeg" srcset="/img/loading.gif" lazyload alt="图1-2"></p><p>此时，A的PR值就可以表示为：</p><script type="math/tex;mode=display">PR(A) = PR(B) + PR(C)</script><p>然而图中除了C之外，B和D都不止有一条出链，所以上面的计算式并不准确。想象一个用户现在在浏览B网页，那么下一步他打开A网页还是D网页在统计上应该是相同概率的。所以A的PR值应该表述为：</p><script type="math/tex;mode=display">PR(A) = \frac{PR(B)}{2} + \frac{PR(C)}{1}</script><p>互联网中不乏一些没有出链的网页，如下图：</p><p><img src="../../img/post/study/pr-2.jpeg" srcset="/img/loading.gif" lazyload alt="图1-3"></p><p>图中的C网页没有出链，对其他网页没有PR值的贡献，我们不喜欢这种自私的网页（其实是为了满足 Markov 链的收敛性），于是设定其对所有的网页（包括它自己）都有出链，则此图中A的PR值可表示为：</p><script type="math/tex;mode=display">PR(A) = \frac{PR(B)}{2} + \frac{PR(C)}{4}</script><p>然而我们再考虑一种情况：互联网中一个网页只有对自己的出链，或者几个网页的出链形成一个循环圈。那么在不断地迭代过程中，这一个或几个网页的PR值将只增不减，显然不合理。如下图中的C网页就是刚刚说的只有对自己的出链的网页：</p><p><img src="../../img/post/study/pr-3.jpeg" srcset="/img/loading.gif" lazyload alt="图1-4"></p><p>可以继续考虑以下几种情况:</p><blockquote><ol><li>完全网络</li><li>散点网络</li><li>环网络</li><li>悬挂节点</li></ol></blockquote><p>为了解决这个问题。我们想象一个随机浏览网页的人，当他到达C网页后，显然不会傻傻地一直被C网页的小把戏困住。我们假定他有一个确定的概率会输入网址直接跳转到一个随机的网页，并且跳转到每个网页的概率是一样的。于是则此图中A的PR值可表示为：</p><script type="math/tex;mode=display">PR(A) = \alpha(\frac{PR(B)}{2}) + \frac{(1 - \alpha)}{4}</script><p>在一般情况下，一个网页的PR值计算如下：</p><script type="math/tex;mode=display">PR(p_{i}) = \alpha \sum_{p_{j} \in M_{p_{i}}} \frac{PR(p_{j})}{L(p_{j})} + \frac{(1 - \alpha)}{N}</script><p>其中，$M_{p_i}$是网页$p_i$所有的入链网页集合，$L(p_j)$是网页$p_j$的出链数目，$N$是网页总数，$\alpha$一般取0.85。</p><blockquote><p><strong>此处可略过不看</strong></p><p>(5)也可以表示为：</p><script type="math/tex;mode=display">PR_{i}(t) = (1-c) \sum_{j=1}^n a_{ji}\frac{PR_{j}(t-1)}{k_{j}^{out}} + \frac{c}{n}</script><p>论文中还给出了一个简易计算方法：</p><script type="math/tex;mode=display">PR(A) = (1-d) + d(\frac{PR(T_{1})}{C(T_{1})} + \dots + \frac{PR(T_{i})}{C(T_{i})})</script></blockquote><p>PageRank算法总的来说就是预先给每个网页一个PR值（下面用PR值指代PageRank值），由于PR值物理意义上为一个网页被访问概率，所以一般是$\frac{1}{N}$，其中$N$是网页总数。因此，一般情况下，所有网页的PR值的总和为1（归一化）。如果不为1的话也可以，最后算出来的不同网页之间PR值的大小关系仍然是正确的，只是不能直接地反映概率了。预先给定PR值后，通过PageRank算法不断迭代，直至达到平稳为止。</p><h3 id="1-3-算法证明"><a href="#1-3-算法证明" class="headerlink" title="1.3 算法证明"></a>1.3 算法证明</h3><p>PageRank算法的证明主要包括两点，设$P_{n}$为第$n$次迭代时各网页PR值组成的列向量<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[PageRank算法从原理到实现](https://www.cnblogs.com/rubinorth/p/5799848.html)">[2]</span></a></sup>：</p><ol><li>$\lim\limits_{n \to \infty}P_n$是否存在？</li><li>如果存在，极限是否与$P_0$的选取无关？</li></ol><p>为了方便证明，先将PR值的计算方法转换一下。仍然以上面例子来说：</p><p><img src="../../img/post/study/pr-3.jpeg" srcset="/img/loading.gif" lazyload alt="图1-5"></p><p>可以用一个矩阵来表示这张图的出链入链关系，$S_{ij}=0$表示$j$网页没有对$i$网页的出链：</p><p>取$e$为所有分量都为 1 的列向量，定义矩阵：</p><script type="math/tex;mode=display">A = \alpha S + \frac{(1 - \alpha)}{N}ee^T</script><p>则PR值的计算如下，其中$P_n$为第$n$次迭代时各网页PR值组成的列向量：</p><script type="math/tex;mode=display">P_{n+1} = A^T P_{n}</script><p>于是计算PR值的过程就变成了一个Markov过程，PageRank算法的证明也就转为证明Markov过程的收敛性证明：如果这个 Markov 过程收敛，那么$\lim\limits<em>{n \to \infty}P</em>{n}$ 存在，且与$P_0$的选取无关。</p><p>若一个Markov过程收敛，那么它的状态转移矩阵$A$需要满足：</p><ol><li>A为随机矩阵</li><li>A是不可约的</li><li>A是非周期的</li></ol><p><strong>第一点</strong>：随机矩阵又叫概率矩阵或 Markov 矩阵，满足以下条件：</p><script type="math/tex;mode=display">令a_{ij}为矩阵A中第i行第j列的元素，则
\forall i = 1 \dots n, j = 1 \dots n, a_{ij} \geq 0, 且
\forall i = 1 \dots n, \sum_{j = 1}^n a_{ij} = 1</script><p>显然我们的$A$矩阵所有元素都大于等于0，并且每一列的元素和都为1。</p><p><strong>第二点</strong>：方阵$A$是不可约的当且仅当与A对应的有向图是强联通的。有向图$G=(V, E)$是强联通的当且仅当对每一对节点对$u,v∈V$，存在从$u$到$v$的路径。因为我们在之前设定用户在浏览页面的时候有确定概率通过输入网址的方式访问一个随机网页，所以$A$矩阵同样满足不可约的要求。</p><p><strong>第三点</strong>：所谓周期性，体现在Markov链的周期性上。即若$A$是周期性的，那么这个Markov链的状态就是周期性变化的。因为A是素矩阵（素矩阵(本原矩阵, 若一个n阶非负不可约矩阵(A的模=单特征值的个数)的单特征值个数为1，则称A为本原矩阵。)指自身的某个次幂为正矩阵的矩阵），所以A是非周期的。</p><p>至此，我们证明了PageRank算法的正确性。</p><h3 id="1-4-算法设计"><a href="#1-4-算法设计" class="headerlink" title="1.4 算法设计"></a>1.4 算法设计</h3><h4 id="1-4-1-幂迭代法"><a href="#1-4-1-幂迭代法" class="headerlink" title="1.4.1 幂迭代法"></a>1.4.1 幂迭代法</h4><p>首先给每个页面赋予随机的PR值，然后通过$P_{n+1}=AP_n$不断地迭代PR值。当满足下面的不等式后迭代结束，获得所有页面的PR值：</p><script type="math/tex;mode=display">|P_{n+1} - P_{n}| < \epsilon</script><h4 id="1-4-2-特征值法"><a href="#1-4-2-特征值法" class="headerlink" title="1.4.2 特征值法"></a>1.4.2 特征值法</h4><p>当上面提到的Markov链收敛时，随机矩阵必有特征值1，且其特征向量所有分量全为正或全为负：</p><script type="math/tex;mode=display">P = AP \Rightarrow P为矩阵A特征值1对应的特征向量</script><h4 id="1-4-3-代数法"><a href="#1-4-3-代数法" class="headerlink" title="1.4.3 代数法"></a>1.4.3 代数法</h4><p>相似的，当上面提到的Markov链收敛时，必有：</p><script type="math/tex;mode=display">\begin{equation}\begin{split}

P = AP &\Rightarrow P = \lgroup \alpha S + \frac{(1 - \alpha)}{N}ee^T \rgroup P \\\\
又&\because e为所有分量都为 1 的列向量，P的所有分量之和为1 \\\\
&\Rightarrow P = \alpha SP + \frac{(1 - \alpha)}{N}e \\\\
&\Rightarrow (ee^T - \alpha S)P = \frac{(1 - \alpha)}{N}e \\\\
&\Rightarrow P = (ee^T - \alpha S)^{-1} \frac{(1 - \alpha)}{N}e

\end{split}\end{equation}</script><h3 id="1-5-算法实现"><a href="#1-5-算法实现" class="headerlink" title="1.5 算法实现"></a>1.5 算法实现</h3><p>对于以下网页关系:</p><p><img src="../../img/post/study/pr-4.jpeg" srcset="/img/loading.gif" lazyload alt="图1-6"></p><p>算法运行结果如下：</p><p><img src="../../img/post/study/pr-5.jpeg" srcset="/img/loading.gif" lazyload alt="图1-7"></p><h4 id="1-5-1-基于迭代的实现"><a href="#1-5-1-基于迭代的实现" class="headerlink" title="1.5.1 基于迭代的实现"></a>1.5.1 基于迭代的实现</h4><p>使用Python基于python-graph-core库实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pygraph.classes.digraph <span class="hljs-keyword">import</span> digraph<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PRIterator</span>:<br>    __doc__ = <span class="hljs-string">&#x27;&#x27;&#x27;计算一张图中的PR值&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, dg</span>):<br>        self.damping_factor = <span class="hljs-number">0.85</span>  <span class="hljs-comment"># 阻尼系数,即α</span><br>        self.max_iterations = <span class="hljs-number">100</span>  <span class="hljs-comment"># 最大迭代次数</span><br>        self.min_delta = <span class="hljs-number">0.00001</span>  <span class="hljs-comment"># 确定迭代是否结束的参数,即ϵ</span><br>        self.graph = dg<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">page_rank</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment">#  先将图中没有出链的节点改为对所有节点都有出链</span><br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> self.graph.nodes():<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.graph.neighbors(node)) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">for</span> node2 <span class="hljs-keyword">in</span> self.graph.nodes():<br>                    digraph.add_edge(self.graph, (node, node2))<br><br>        nodes = self.graph.nodes()<br>        graph_size = <span class="hljs-built_in">len</span>(nodes)<br><br>        <span class="hljs-keyword">if</span> graph_size == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> &#123;&#125;<br>        page_rank = <span class="hljs-built_in">dict</span>.fromkeys(nodes, <span class="hljs-number">1.0</span> / graph_size)  <span class="hljs-comment"># 给每个节点赋予初始的PR值</span><br>        damping_value = (<span class="hljs-number">1.0</span> - self.damping_factor) / graph_size  <span class="hljs-comment"># 公式中的(1−α)/N部分</span><br><br>        flag = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.max_iterations):<br>            change = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodes:<br>                rank = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> incident_page <span class="hljs-keyword">in</span> self.graph.incidents(node):  <span class="hljs-comment"># 遍历所有“入射”的页面</span><br>                    rank += self.damping_factor * (page_rank[incident_page] / <span class="hljs-built_in">len</span>(self.graph.neighbors(incident_page)))<br>                rank += damping_value<br>                change += <span class="hljs-built_in">abs</span>(page_rank[node] - rank)  <span class="hljs-comment"># 绝对值</span><br>                page_rank[node] = rank<br><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is NO.%s iteration&quot;</span> % (i + <span class="hljs-number">1</span>))<br>            <span class="hljs-built_in">print</span>(page_rank)<br><br>            <span class="hljs-keyword">if</span> change &lt; self.min_delta:<br>                flag = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> flag:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;finished in %s iterations!&quot;</span> % node)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;finished out of 100 iterations!&quot;</span>)<br>        <span class="hljs-keyword">return</span> page_rank<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    dg = digraph()<br><br>    dg.add_nodes([<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>])<br><br>    dg.add_edge((<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>))<br>    dg.add_edge((<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>))<br>    dg.add_edge((<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>))<br>    dg.add_edge((<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>))<br>    dg.add_edge((<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>))<br>    dg.add_edge((<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>))<br>    dg.add_edge((<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>))<br>    dg.add_edge((<span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>))<br><br>    pr = PRIterator(dg)<br>    page_ranks = pr.page_rank()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The final page rank is\n&quot;</span>, page_ranks)<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">finished <span class="hljs-keyword">in</span> 36 iterations!<br>The final page rank is<br>&#123;<span class="hljs-string">&#x27;A&#x27;</span>: 0.2963453309000821, <span class="hljs-string">&#x27;C&#x27;</span>: 0.11396451042168992, <span class="hljs-string">&#x27;B&#x27;</span>: 0.11396451042168992, <span class="hljs-string">&#x27;E&#x27;</span>: 0.31334518664434013, <span class="hljs-string">&#x27;D&#x27;</span>: 0.16239975107315852&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-2-基于MapReduce的实现"><a href="#1-5-2-基于MapReduce的实现" class="headerlink" title="1.5.2 基于MapReduce的实现"></a>1.5.2 基于MapReduce的实现</h4><p>参考引用资料<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Using MapReduce to compute PageRank](http://michaelnielsen.org/blog/using-mapreduce-to-compute-pagerank/)">[3]</span></a></sup>实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 暂无</span><br></code></pre></td></tr></table></figure><h3 id="1-6-算法的缺点"><a href="#1-6-算法的缺点" class="headerlink" title="1.6 算法的缺点"></a>1.6 算法的缺点</h3><p>PR算法有几个缺点<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[PageRank算法从原理到实现](https://www.cnblogs.com/rubinorth/p/5799848.html)">[2]</span></a></sup>，这里我们主要关注其中一个：</p><p>算法规定从当前网页上随机跳转到下一个网页的概率都相同，然而这并不符合现实中人们的网页浏览方式，明显在内容丰富的网页上浏览时相比一个无趣的网页，人们跳转页面的概率大不相同。此外，随机最优参数$\alpha$的选取需要通过实验获得，对于不同的网络，参数的大小也不相同，不存在一个普遍参数。</p><h2 id="2-LeaderRank算法"><a href="#2-LeaderRank算法" class="headerlink" title="2 LeaderRank算法"></a>2 LeaderRank算法</h2><p>在许多在线社区中，用户可以选择其他用户作为他们的“意见领袖”。 我们通过一个网络来表示这些<code>User—User</code>关系，该网络具有从粉丝指向其领袖的有向链接，核心意见领袖会有大量的入链。目标是根据此网络拓扑对所有用户进行重要性排名。</p><p>为解决上述PageRank算法的缺点，在识别社交网络中高影响力用户时，吕琳媛等提出了改进的LeaderRank算法<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[LÜ L, ZHANG Y-C, YEUNG C H, et al. Leaders in Social Networks, the Delicious Case[J]. PLoS ONE, 2011, 6(6): e21202. DOI:10.1371/journal.pone.0021202.](https://doi.org/10.1371/journal.pone.0021202)">[4]</span></a></sup><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[LeaderRank](https://www.centiserver.org/?q1=centrality&q2=LeaderRank)">[5]</span></a></sup>。通过向网络中增加一个与原网络所有节点双向链接“基准节点”，取代PageRank算法中人为指定的随机跳转概率参数，同时提高了算法的收敛速度。</p><h3 id="2-1-算法思路"><a href="#2-1-算法思路" class="headerlink" title="2.1 算法思路"></a>2.1 算法思路</h3><p>设想一个由 N 个节点和 M 个有向链路组成的网络G。节点对应用户，链接根据领袖和粉丝之间的关系建立。为了对用户进行排名，我们引入了一个“基准节点”，该节点通过双向链接连接到每个用户（见图2-1）。G因此变为了由$N+1$个节点和$M+2N$条边构成的强连通网络。为了开始排序过程，我们为除基准节点之外的每个节点分配一个分数单元，然后通过有向链接将其均匀分配给节点的指向节点。该过程一直持续达到稳定状态。</p><p><img src="../../img/post/study/leader-rank-mind.png" srcset="/img/loading.gif" lazyload alt="图2-1: LeaderRank算法概念图" style="zoom:40%"></p><h3 id="2-2-算法设计"><a href="#2-2-算法设计" class="headerlink" title="2.2 算法设计"></a>2.2 算法设计</h3><p>数学意义上，这个过程相当于有向网络上的随机游走，并且该过程由随机矩阵 P 描述，其中元素$p<em>{ij} = a</em>{ij}/k<em>i^{out}$ 表示随机游走者下一步从 i 走到 j 的概率。如果节点 i 指向 j，则$a</em>{ij}=1$，否则为 0，$k_i^{out}$ 表示出度，即 i 的领袖数量。因此，这个概率流向可以看作粉丝 i 对领袖 j 的投票。</p><p>用$s_i(t)$表示节点 i 在时间 t 的得分，有：</p><script type="math/tex;mode=display">s_{i}(t+1) = \sum_{j=1}^{N+1} \frac{a_{ji}}{k_{j}^{out}} s_{j}(t),  \quad t=0, 1, 2, \dots, n.</script><p>初始分数规则：基准节点的$s_g(0)=0$，其它所有节点 i 的$s_i (0)=1$。</p><p>基准节点的存在使得 P 不可约，因为网络是强连通的。基准节点还确保任何节点的大小为 2 和 3 的环路共存，这意味着 $P^6$ 为正，即 $P^6$ 的所有元素都大于零。由于 $P^n$ 对某些自然数 n 为正，因此 P 是和非负基元矩阵。根据 Perron-Frobenius 定理，P 具有最大特征值 1 和唯一特征向量。</p><p>因此，所有 i 的分数 $s_i(t)$ 将收敛到唯一的稳定状态，表示为 $s_i(t_c)$，其中 $t_c$ 是收敛时间。在稳定状态下，我们将基准节点的分数平均分配给所有其他节点。用户 i 的最终影响力得分S，即：</p><script type="math/tex;mode=display">S_i = s_i(t_c) + \frac{s_g(t_c)}{N}</script><p>其中，$s_g(t_c)$是基准节点在稳态时的得分。</p><h3 id="2-3-算法优点"><a href="#2-3-算法优点" class="headerlink" title="2.3 算法优点"></a>2.3 算法优点</h3><p>基于上述特性，在排名中应用 LeaderRank 有几个优点，包括：</p><ol><li>无参数</li><li>广泛适用于任何类型的图</li><li>收敛到唯一的排名序列</li><li>初始条件的独立性</li></ol><h3 id="2-4-算法实现"><a href="#2-4-算法实现" class="headerlink" title="2.4 算法实现"></a>2.4 算法实现</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% This is a Matlab M−file for LeaderRank.</span><br><br>E=load(<span class="hljs-string">&#x27;Network.dat&#x27;</span>); <span class="hljs-comment">% Read the network data with different pairs</span><br>													<span class="hljs-comment">% of &#x27;fan leader&#x27; in consecutive rows, and  the</span><br>													<span class="hljs-comment">% labels of nodes should start from 1</span><br>l=<span class="hljs-built_in">length</span>(E);						<span class="hljs-comment">% l is the number of links</span><br>N=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(E));					<span class="hljs-comment">% N is the number of nodes.</span><br><br><span class="hljs-comment">% Add ground node and create adjacency matrix P</span><br>EG1=<span class="hljs-built_in">zeros</span>(N, <span class="hljs-number">2</span>);	<span class="hljs-comment">% N rows 2 cols</span><br>EG2=<span class="hljs-built_in">zeros</span>(N, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:N<br>		EG1(<span class="hljs-built_in">i</span>, <span class="hljs-number">1</span>)=N+<span class="hljs-number">1</span>;<br>		EG1(<span class="hljs-built_in">i</span>, <span class="hljs-number">2</span>)=<span class="hljs-built_in">i</span>;<br><span class="hljs-keyword">end</span><br>EG2(:, <span class="hljs-number">1</span>)=EG1(:, <span class="hljs-number">2</span>);<br>EG2(:, <span class="hljs-number">2</span>)=EG1(:, <span class="hljs-number">1</span>);<br>E=[E; EG1; EG2];<br>P=sparse(E(:, <span class="hljs-number">1</span>), E(:, <span class="hljs-number">2</span>), <span class="hljs-number">1</span>);<br>D_in=sum(P);		<span class="hljs-comment">% in degree</span><br>D_out=sum(P&#x27;);	<span class="hljs-comment">% out degree</span><br><br><span class="hljs-comment">% Transition matrix PP</span><br>EE=<span class="hljs-built_in">zeros</span>(N+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=<span class="hljs-number">1</span>:N+<span class="hljs-number">1</span><br>		EE(<span class="hljs-built_in">j</span>, <span class="hljs-number">1</span>)=<span class="hljs-built_in">j</span>;<br>		EE(<span class="hljs-built_in">j</span>, <span class="hljs-number">2</span>)=<span class="hljs-number">1</span>/D_out(<span class="hljs-built_in">j</span>);<br><span class="hljs-keyword">end</span><br>D=sparse(EE(:, <span class="hljs-number">1</span>), EE(:, <span class="hljs-number">1</span>), EE(:, <span class="hljs-number">2</span>));<br>PP=D∗P;<br><br><span class="hljs-comment">% Diffusion to stable state.</span><br>God=<span class="hljs-built_in">zeros</span>(N+<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>God(<span class="hljs-number">1</span>:N, <span class="hljs-number">1</span>)=<span class="hljs-number">1</span>;								<span class="hljs-comment">% Assign initial resource</span><br>error=<span class="hljs-number">10000</span>;									<span class="hljs-comment">% error is the average error of nodes&#x27; scores.</span><br>error_threshold=<span class="hljs-number">0.00002</span>;			<span class="hljs-comment">% It is a tunable parameter controlling the</span><br>																<span class="hljs-comment">% error tolerance.</span><br>step=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> error&gt;error_threshold<br>		step<br>		M=God;<br>		God=PP&#x27;∗God;							<span class="hljs-comment">% P&#x27; means the transpose of P</span><br>		error=sum(<span class="hljs-built_in">abs</span>(God−M)./M)/(N+<span class="hljs-number">1</span>);<br>		step=step+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span><br>b=God(N+<span class="hljs-number">1</span>)/N;<br>God=God+b;<br>God(N+<span class="hljs-number">1</span>)=<span class="hljs-number">0</span>;<br><br><span class="hljs-comment">% Write the ranking results to &quot;Results.dat&quot;: node&#x27;s ID &amp; Score</span><br>R=<span class="hljs-built_in">zeros</span>(N, <span class="hljs-number">2</span>);<br>R(:, <span class="hljs-number">1</span>)=[<span class="hljs-number">1</span>:N]&#x27;;<br>R(:, <span class="hljs-number">2</span>)=God(<span class="hljs-number">1</span>:N);<br>[b, pos]=<span class="hljs-built_in">sort</span>(−R(:, <span class="hljs-number">2</span>));<br>R=R(pos, :);<br>fid=fopen(<span class="hljs-string">&#x27;Results.dat&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:N<br>		fprintf(fid, <span class="hljs-string">&#x27;%d%f\n&#x27;</span>, R(<span class="hljs-built_in">i</span>, <span class="hljs-number">1</span>), R(<span class="hljs-built_in">i</span>, <span class="hljs-number">2</span>));<br><span class="hljs-keyword">end</span><br>fclose(fid);<br></code></pre></td></tr></table></figure><h2 id="3-CoRank算法"><a href="#3-CoRank算法" class="headerlink" title="3 CoRank算法"></a>3 CoRank算法</h2><h3 id="3-1-算法构思"><a href="#3-1-算法构思" class="headerlink" title="3.1 算法构思"></a>3.1 算法构思</h3><h3 id="3-2-子算法设计"><a href="#3-2-子算法设计" class="headerlink" title="3.2 子算法设计"></a>3.2 子算法设计</h3><h4 id="3-2-1-基础属性重要性算法"><a href="#3-2-1-基础属性重要性算法" class="headerlink" title="3.2.1 基础属性重要性算法"></a>3.2.1 基础属性重要性算法</h4><script type="math/tex;mode=display">w_{bp} = |\vec x| = \sqrt{x_1^2+x_2^2+\dots+x_n^2}</script><p>模长 or 特征向量中心性？</p><h4 id="3-2-2-基于临域相似度的节点核心度算法"><a href="#3-2-2-基于临域相似度的节点核心度算法" class="headerlink" title="3.2.2 基于临域相似度的节点核心度算法"></a>3.2.2 基于临域相似度的节点核心度算法</h4><script type="math/tex;mode=display">\begin{align}
LLS(i) &= \sum_{a, b \in n_i} (1-sim(a,b)) + c \notag \\
&= k_i - \sum_{a, b \in n_i} sim(a, b) + c \\
\end{align}</script><p>$if \qquad sim(a,b) = 1 \qquad then \qquad c = \frac {2}{n_i(n_i-1)} \notag \qquad else \qquad c = 0$</p><h4 id="3-2-3-节点综合情感权重算法"><a href="#3-2-3-节点综合情感权重算法" class="headerlink" title="3.2.3 节点综合情感权重算法"></a>3.2.3 节点综合情感权重算法</h4><script type="math/tex;mode=display">w_{ji} = \frac{\sum (e_{ji}^{pos}-e_{ji}^{neg})}{n_{ji}} + r_{ji}</script><p>其中，$w<em>{ji} \in [-1, 1]$，为节点$j$对节点$i$的综合情感权重；$r</em>{ji}$为节点是否互为好友；如果$i=g$, 则$w_{jg} = 0$。</p><h4 id="3-2-4-CoRank-核心用户识别算法"><a href="#3-2-4-CoRank-核心用户识别算法" class="headerlink" title="3.2.4 CoRank 核心用户识别算法"></a>3.2.4 CoRank 核心用户识别算法</h4><p>使用用户$i$到$j$的综合情感倾向作为节点间的有向边权重，生成状态转移矩阵，Ground节点与其它所有节点间的权重均为 1 均值</p><p>i指向g时，w取i指出去的所有值的均值，g指向i时，w为1/N</p><script type="math/tex;mode=display">s_{i}(t+1) = \sum_{j=1}^{N+1} \frac{w_{ji}}{\sum_{l=1}^{N+1}w_{jl}^{out}} s_{j}(t),  \quad t=0, 1, 2, \dots, n.</script><script type="math/tex;mode=display">S_i = s_i(t_c) + \frac{s_g(t_c)}{N}</script><p>负值乘以负权重？怎么传递？还是平移量纲？</p><p>平移量纲，使得$w_e \in [0, 2]$，如果$i=g$, 则$w_e = 1$。</p><p>以式（16）和（17）的结果归一化后求和，初始化CR向量</p><script type="math/tex;mode=display">CR_1 = [cr_1^1, cr_2^1, \dots , cr_n^1]^{T} \\
迭代n次后的结果 \\
CR_n = [cr_1^n, cr_2^n, \dots , cr_n^n]^{T}</script><p>以情感分析结果和式（18）构造状态转移矩阵</p><script type="math/tex;mode=display">A</script><p>则</p><script type="math/tex;mode=display">CR_{n+1} = ACR_{n}</script><h4 id="3-2-5-数据的标准化和归一化方法"><a href="#3-2-5-数据的标准化和归一化方法" class="headerlink" title="3.2.5 数据的标准化和归一化方法"></a>3.2.5 数据的标准化和归一化方法</h4><ul><li><p>Min-Max归一化</p><script type="math/tex;mode=display">X_{norm} = \frac{X_i-X{min}}{X_{max}-X_{min}}</script></li><li><p>均值标准化</p><script type="math/tex;mode=display">X_{std} = \frac{X_i-\mu}{\sigma}</script></li></ul><h3 id="3-3-算法实现A-gt-B-一样效果"><a href="#3-3-算法实现A-gt-B-一样效果" class="headerlink" title="3.3 算法实现A-&gt;B: 一样效果"></a>3.3 算法实现A-&gt;B: 一样效果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sequence">A-&gt;B: react<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.sciencedirect.com/science/article/abs/pii/S016975529800110X?via%3Dihub">BRIN S, PAGE L. The anatomy of a large-scale hypertextual Web search engine[J]. Computer Networks and ISDN Systems, 1998, 30(1–7): 107–117. DOI:10.1016/s0169-7552(98)00110-x.</a> <a href="#fnref:1" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/rubinorth/p/5799848.html">PageRank算法从原理到实现</a> <a href="#fnref:2" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a target="_blank" rel="noopener external nofollow noreferrer" href="http://michaelnielsen.org/blog/using-mapreduce-to-compute-pagerank/">Using MapReduce to compute PageRank</a> <a href="#fnref:3" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://doi.org/10.1371/journal.pone.0021202">LÜ L, ZHANG Y-C, YEUNG C H, et al. Leaders in Social Networks, the Delicious Case[J]. PLoS ONE, 2011, 6(6): e21202. DOI:10.1371/journal.pone.0021202.</a> <a href="#fnref:4" rev="footnote" class="footnote-backref">↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.centiserver.org/?q1=centrality&amp;q2=LeaderRank">LeaderRank</a> <a href="#fnref:5" rev="footnote" class="footnote-backref">↩</a></span></span></li></ol></div></section></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Private/">#Private</a> <a href="/tags/PageRank/">#PageRank</a> <a href="/tags/LeaderRank/">#LeaderRank</a> <a href="/tags/CoRank/">#CoRank</a></div></div><div class="license-box my-3"><div class="license-title"><div>从PageRank到CoRank</div><div>https://jbiter.github.io/p/1fb84bb.html</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>布衣</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2021年7月6日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/" rel="external nofollow noreferrer"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/p/a9baf53c.html" title="信息检索运算符使用方法"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">信息检索运算符使用方法</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/p/fde983e1.html" title="在内网环境中配置Jupyter Notebook服务"><span class="hidden-mobile">在内网环境中配置Jupyter Notebook服务</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js",function(){mermaid.initialize({theme:"default"}),Fluid.events.registerRefreshCallback(function(){"mermaid"in window&&mermaid.init()})})</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><div class="copyright"><a href="https://hexo.io" target="_blank" rel="nofollow noopener">Powered by Hexo</a> &nbsp;<i class="iconfont icon-pen"></i>&nbsp; <a href="https://hexo.fluid-dev.com/docs/" target="_blank" rel="nofollow noopener">Styled by Fluid</a></div><div class="copyright">All Content Rights Reserved</div><div class="copyright">Copyright <i class="iconfont icon-copyright"></i> 2021</div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible"))}))})</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback(function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script src="/js/custom.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>